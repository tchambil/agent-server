options{  LOOKAHEAD= 1;  STATIC = false;}PARSER_BEGIN(PathExpression)package it.unibz.inf.krdb.swget.regExpression.parser;import it.unibz.inf.krdb.swget.regExpression.automaton.*;import java.io.UnsupportedEncodingException;public class PathExpression{  String reg;  RegularExpressionBase reg1;  public PathExpression(String reg)  {    this.reg = reg;  }  public RegularExpressionBase getRegExpress()  {    return reg1;  }  public RegularExpressionBase startParsing()   throws ParseException, TokenMgrError  {    PathExpression parser = null;    try    {      parser = new PathExpression(new java.io.ByteArrayInputStream(reg.getBytes("UTF-8")));    }    catch (UnsupportedEncodingException e)    {      e.printStackTrace();    }    reg1 = parser.NExpr();    return reg1;  }}PARSER_END(PathExpression)/*Lexical Analizer*/SKIP :{  " "}SKIP :{  "\n"| "\r"| "\r\n"}TOKEN :{  < PLUS : "+" >| < KLEENE : "*" >| < QUESTION : "?" >| < INTERVAL : "-" >| < LBRACKET : "(" >| < RBRACKET : ")" >| < LANGLEBRACKET : "<" >| < RANGLEBRACKET : ">" >| < OR : "|" >| < AND : "/" >}TOKEN :{  < PREDICATE :    "<"    (      [ "a"-"z", "A"-"Z" ] ([ "a"-"z", "A"-"Z", "0"-"9", "+", "-", ".", ":", "#", "/" ])*    | "_"    )    ">" >| < NUMBER :    (      [ "1"-"9" ] ([ "0"-"9" ])*    ) >| < SPRQLQUERY : "[" (~[ "]" ])+ "]" >| < ACTION : "ACT[" (~[ "]" ])+ "]" >}/*syntactic analyser*/RegularExpressionBase NExpr():{   RegularExpressionBase reg;}{reg=Start()< EOF >{  return reg;}}RegularExpressionBase Start() :{  RegularExpressionBase reg;  RegularExpressionBase reg1;  String trig;}{//  {System.out.println("Start - > SUBEXPRESSION OREXPRESSION");}  reg = SUBEXPRESSION()  reg1 = OREXPRESSION(reg)  {    return reg1;  }}RegularExpressionBase OREXPRESSION(RegularExpressionBase reg) :{  RegularExpressionBase reg1;}{//  {System.out.println("OREXPRESSION - > | Start");}  < OR >   reg1 = Start()  {    return new RegExpUnion(reg, reg1);  }|//< EOF >//  {System.out.println("OREXPRESSION - > eps");}  {    return reg;  }}RegularExpressionBase SUBEXPRESSION() :{  RegularExpressionBase reg;  RegularExpressionBase reg1;  RegularExpressionBase reg2;  Token t;}{//  {System.out.println("SUBEXPRESSION - > BASEEXPRESSION REPETESYMBOL TEST ANDEXPRESSION");}  reg = BASEEXPRESSION()  reg1 = REPETESYMBOL(reg)  reg2 = TEST()  {      if (reg2 != null) reg1 = new RegExpIntersect(reg1, reg2);  }  reg1 = ANDEXPRESSION(reg1)  {    return reg1;  }}RegularExpressionBase ANDEXPRESSION(RegularExpressionBase reg) :{  RegularExpressionBase reg1;}{//  {System.out.println("ANDEXPRESSION - > / SUBEXPRESSION");}  < AND >  reg1 = SUBEXPRESSION()  {    return new RegExpIntersect(reg, reg1);  }|//  {System.out.println("ANDEXPRESSION - > eps");}  {    return reg;  }}RegularExpressionBase REPETESYMBOL(RegularExpressionBase reg) :{  RegularExpressionBase reg1;}{  < KLEENE >//  {System.out.println("REPETESYMBOL - > *");}  {    reg1 = new RegExpRepeat(reg);    return reg1;  }| < PLUS >//  {System.out.println("REPETESYMBOL - > +");}  {    reg1 = new RegExpRepeatPlus(reg);    return reg1;  }| < QUESTION > // {System.out.println("REPETESYMBOL - > ?");}  {    reg1 = new RegExpPossiblyMissing(reg);    return reg1;  }|//  {System.out.println("REPETESYMBOL - > REPETITION");}  reg1 = REPETITION(reg)  {    return reg1;  }| // {System.out.println("REPETESYMBOL - > eps");}  {    return reg;  }}RegularExpressionBase REPETITION(RegularExpressionBase reg) :{  int repi, repf;  Token ti, tf;  RegularExpressionBase regf;}{  {//    System.out.println("REPETITION - > <NUMBER-NUMBER>");  }  < LANGLEBRACKET > ti = < NUMBER > < INTERVAL > tf = < NUMBER >  {    repi = Integer.parseInt(ti.image);    repf = Integer.parseInt(tf.image);  }  < RANGLEBRACKET >  {    regf=null;    if (repi == 0)    {      regf = new RegExpPossiblyMissing(reg);    }    else    {      regf=reg;      for (int i = 2; i <= repi; i++)      {        regf = new RegExpIntersect(regf, reg);      }    }    for (int i = repi + 1; i <= repf; i++)    {      regf = new RegExpIntersect(regf, new RegExpPossiblyMissing(reg));    }    return regf;  }}RegularExpressionBase BASEEXPRESSION() :{  Token t;  RegularExpressionBase reg;}{//  {System.out.println("BASEEXPRESSION - > PRED");}  t = < PREDICATE >  {    if (t.image.equals("<_>")) reg = new RegExpPred(true);    else reg = new RegExpPred(t.image);    return reg;  }|//  {System.out.println("BASEEXPRESSION - > (Start)");}  < LBRACKET > reg = Start() < RBRACKET >  {    return reg;  }| t = < ACTION >//  {System.out.println("BASEEXPRESSION - > ACTION");}  {    return reg = new RegExpPred(t.image);  }}RegularExpressionBase TEST() :{  Token t;  RegularExpressionBase reg;}{ // {System.out.println("TEST - > QUERY");}  t = < SPRQLQUERY >  {    reg = new RegExpPred(t.image);    return reg;  }| // {System.out.println("TEST - > EPS");}  {    return null;  }}